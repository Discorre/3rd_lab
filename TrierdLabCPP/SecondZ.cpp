//#include <iostream>  // Подключение заголовочного файла для ввода/вывода
//#include <cmath>  // Подключение заголовочного файла для математических функций
//#include <random>  // Подключение заголовочного файла для генерации случайных чисел
//#include <vector>  // Подключение заголовочного файла для использования векторов
//#include <string>  // Подключение заголовочного файла для работы со строками
//#include <tuple>  // Подключение заголовочного файла для работы с кортежами
//#include <iomanip>  // Подключение заголовочного файла для работы с манипуляторами формата
//
//using namespace std;  // Использование стандартного пространства имен
//
//// Объявление функции MillerTest с возвращаемым значением tuple<string, int>
////tuple<string, int> MillerTest(int n, vector<int>& c, int t);
//
//// Объявление функции Eratosphene с возвращаемым значением vector<int>
//static vector<int> Eratosphene(int n) {
//    // Объявление и инициализация вектора all
//    vector<int> all;
//    // Объявление и инициализация вектора b
//    vector<int> b;
//    // Заполнение вектора all числами от 2 до n
//    for (size_t i = 2; i <= n; i++) {
//        all.push_back(i);
//    }
//    int i = 0;
//    // Цикл по всем элементам вектора all
//    while (i < all.size()) {
//        // Очистка вектора b
//        b.clear();
//        // Копирование элементов от 0 до i из вектора all в вектор b
//        for (int j = 0; j <= i; j++) {
//            b.push_back(all[j]);
//        }
//        // Проверка оставшихся элементов вектора all на делимость на элементы вектора b
//        for (size_t z = static_cast<size_t>(i) + 1; z < all.size(); z++) {
//            // Если элемент не делится, добавляем его в вектор b
//            if (all[z] % all[i] != 0) {
//                b.push_back(all[z]);
//            }
//        }
//        // Очистка вектора all и копирование в него элементов из вектора b
//        all.clear();
//        all = b;
//        i++;
//    }
//    // Возвращение вектора all
//    return all;
//}
//
//// Определение функции генерации случайного числа в заданном диапазоне [a, n]
//static int rn(int a, int n) {
//    // Инициализация генератора случайных чисел
//    random_device rd;
//    mt19937 gen(rd());
//
//    // Создание распределения для заданного диапазона [a, n]
//    uniform_int_distribution<int> distribution(a, n);
//
//    // Генерация случайного числа в заданном диапазоне и возврат его
//    return distribution(gen);
//}
//
//static tuple<string, int> MillerTest(int n, vector<int>& c, int t) {
//    // Функция MillerTest принимает на вход число n, вектор целых чисел c и число t.
//    // Ожидается, что вектор c содержит возможные делители числа n.
//
//    int n1 = n - 1; // Вычисляем n - 1 и сохраняем в переменной n1.
//    vector<int> delit; // Создаем вектор delit для хранения делителей n - 1.
//
//    // Проходим по всем элементам вектора c.
//    for (size_t i = 0; i < c.size(); i++) {
//        // Если n1 равно 0 или текущий элемент c больше n1, выходим из цикла.
//        if (n1 == 0 || c[i] > n1) {
//            break;
//        }
//        // Если n1 делится на текущий элемент c без остатка, добавляем c[i] в вектор delit.
//        if (n1 % c[i] == 0) {
//            delit.push_back(c[i]);
//            // Продолжаем делить n1 на c[i] до тех пор, пока деление нацело возможно.
//            while (n1 % c[i] == 0 && n1 != 0) {
//                n1 = n1 / c[i];
//            }
//        }
//    }
//
//    vector<int> a; // Создаем вектор a для хранения случайных чисел.
//    int ai; // Переменная для хранения текущего случайного числа.
//
//    // Генерируем случайные числа, пока размер вектора a не станет равным t.
//    while (a.size() != t) {
//        ai = rn(2, n); // Генерируем случайное число в диапазоне [2, n - 1].
//        // Если ai не содержится в векторе a, добавляем его в вектор.
//        if (find(a.begin(), a.end(), ai) >= a.end()) {
//            a.push_back(ai);
//        }
//    }
//
//    int res = 1; // Инициализируем переменную res значением 1.
//
//    // Проверяем каждое число в векторе a на простоту методом Миллера-Рабина.
//    for (size_t i = 0; i < a.size(); i++) {
//        res = a[i] % n; // Вычисляем a[i] mod n и сохраняем результат в переменной res.
//        for (int j = 2; j <= n - 1; j++) {
//            res *= a[i]; // Умножаем res на a[i].
//            res = res % n; // Вычисляем остаток от деления res на n.
//        }
//        // Если результат не равен 1, возвращаем кортеж с сообщением " - составное число" и значением 0.
//        if (res != 1) {
//            return make_tuple("n - составное число", 0);
//        }
//    }
//
//    int res2; // Переменная для хранения промежуточных результатов во втором цикле.
//    double prom;
//    bool flag = true; // Флаг для отслеживания простоты числа.
//    double n32 = (double)(n - 1); // Приводим n - 1 к типу double.
//    double deliti;
//
//    // Проверяем каждый делитель n - 1 на простоту методом Миллера-Рабина.
//    for (size_t i = 0; i < delit.size(); i++) {
//        flag = true; // Устанавливаем флаг в исходное значение.
//        for (int j = 0; j < a.size(); j++) {
//            res2 = a[j] % n; // Вычисляем a[j] mod n и сохраняем результат в переменной res2.
//            deliti = (double)delit[i]; // Приводим текущий делитель к типу double.
//            prom = n32 / deliti; // Вычисляем значение prom.
//            // Повторяем операцию a[j]^delit[i] mod n для промежуточного результата res2.
//            for (int d = 2; d <= prom; d++) {
//                res2 *= a[j];
//                res2 = res2 % n;
//            }
//            // Если результат не равен 1, устанавливаем флаг в false и выходим из цикла.
//            if (res2 != 1) {
//                flag = false;
//                break;
//            }
//        }
//        // Если флаг остается true, возвращаем кортеж с сообщением " - вероятно, составное число" и значением 0.
//        if (flag) {
//            return make_tuple(" - вероятно, составное число", 0);
//        }
//    }
//    // Если не было обнаружено причин считать число составным, возвращаем кортеж с сообщением " - простое число" и значением 1.
//    return make_tuple(" - простое число", 1);
//}
//
//
//
//static tuple<string, int> PoklingtonTest(int n, vector<int> delit, int t) {
//    // Функция PoklingtonTest принимает на вход число n, вектор целых чисел delit и число t.
//    // Ожидается, что вектор delit содержит возможные делители числа n - 1.
//
//    vector<int> a; // Создаем вектор a для хранения случайных чисел.
//    int ai; // Переменная для хранения текущего случайного числа.
//
//    // Генерируем случайные числа, пока размер вектора a не станет равным t.
//    while (a.size() != t) {
//        ai = rn(2, n - 1); // Генерируем случайное число в диапазоне [2, n - 1].
//        // Если ai не содержится в векторе a, добавляем его в вектор.
//        if (find(a.begin(), a.end(), ai) >= a.end()) {
//            a.push_back(ai);
//        }
//    }
//
//    int res = 1; // Инициализируем переменную res значением 1.
//
//
//    // Проверяем каждое число в векторе a на простоту методом Миллера-Рабина.
//    for (size_t i = 0; i < a.size(); i++) {
//        res = a[i] % n; // Вычисляем a[i] mod n и сохраняем результат в переменной res.
//        for (int j = 2; j <= n - 1; j++) {
//            res *= a[i]; // Умножаем res на a[i].
//            res = res % n; // Вычисляем остаток от деления res на n.
//        }
//        // Если результат не равен 1, возвращаем кортеж с сообщением " - составное число" и значением 0.
//        if (res != 1) {
//            return make_tuple(" - составное число", 0);
//        }
//    }
//
//    int res2; // Переменная для хранения промежуточных результатов во втором цикле.
//    double prom;
//    bool flag = true; // Флаг для отслеживания простоты числа.
//    double n32 = (double)(n - 1); // Приводим n - 1 к типу double.
//    double deliti;
//
//    // Проверяем каждое число в векторе a на простоту, используя делители из вектора delit.
//    for (int j = 0; j < a.size(); j++) {
//        flag = true; // Устанавливаем флаг в исходное значение.
//        for (int i = 0; i < delit.size(); i++) {
//            res2 = a[j] % n; // Вычисляем a[j] mod n и сохраняем результат в переменной res2.
//            deliti = (double)delit[i]; // Приводим текущий делитель к типу double.
//            prom = n32 / deliti; // Вычисляем значение prom.
//            // Повторяем операцию a[j]^delit[i] mod n для промежуточного результата res2.
//            for (int d = 2; d <= prom; d++) {
//                res2 *= a[j];
//                res2 = res2 % n;
//            }
//            // Если результат равен 1, устанавливаем флаг в false и выходим из цикла.
//            if (res2 == 1) {
//                flag = false;
//                break;
//            }
//        }
//        // Если флаг остается true, возвращаем кортеж с сообщением " - простое число" и значением 1.
//        if (flag) {
//            return make_tuple(" - простое число", 1);
//        }
//    }
//    // Если не было обнаружено причин считать число составным, возвращаем кортеж с сообщением " - вероятно, составное число" и значением 0.
//    return make_tuple(" - вероятно, составное число", 0);
//}
//
//// Определение функции генерации случайного числа в заданном интервале [a, b]
//static double rn2GOST(double a, double b) {
//    // Инициализация генератора случайных чисел
//    random_device rd;
//    mt19937 gen(rd());
//
//    // Создание распределения для заданного интервала [a, b] с одной цифрой после запятой
//    uniform_real_distribution<double> distribution(a, b);
//    double randomNumber = distribution(gen);
//
//    // Округление результата до одной цифры после запятой
//    randomNumber = round(randomNumber * 10.0) / 10.0;
//    return randomNumber;
//}
//
//static int GOSTP341004(int q, int bit) {
//    double n; // Объявление переменной n типа double для хранения значения числа n
//    double epsilon; // Объявление переменной epsilon типа double для хранения значения случайной переменной
//    int p; // Объявление переменной p типа int для хранения простого числа p
//
//    // Бесконечный цикл для поиска подходящего значения p
//    while (true) {
//        // Генерация случайной переменной epsilon в диапазоне [0, 1)
//        epsilon = rn2GOST(0, 1);
//        // Вычисление значения n по формуле
//        n = pow(2, bit - 1) / q + (pow(2, bit - 1) * epsilon) / q;
//        // Если n - нечетное, увеличиваем его на 1
//        if ((int)n % 2 == 1) {
//            n++;
//        }
//        // Поиск простого числа p
//        for (size_t u = 0; true; u += 2) {
//            // Вычисление значения p
//            p = (n + u) * q + 1;
//            // Если p больше чем 2 в степени bit, прекращаем цикл
//            if (p > pow(2, bit)) {
//                break;
//            }
//            // Проверка условий Миллера-Рабина для числа p
//            bool flag1 = false; // Флаг для первого условия
//            bool flag2 = false; // Флаг для второго условия
//            int res = 2 % p;
//            // Вычисление a^(p-1) mod p
//            for (size_t i = 2; i <= static_cast<unsigned long long>(p) - 1; i++) {
//                res *= 2;
//                res = res % p;
//            }
//            // Если a^(p-1) mod p == 1, устанавливаем флаг1 в true
//            if (res == 1) {
//                flag1 = true;
//            }
//            res = 2 % p;
//            // Вычисление a^(n+u) mod p
//            for (size_t i = 2; i <= n + u; i++) {
//                res *= 2;
//                res = res % p;
//            }
//            // Если a^(n+u) mod p != 1, устанавливаем флаг2 в true
//            if (res != 1) {
//                flag2 = true;
//            }
//            // Если оба условия выполняются, возвращаем найденное простое число p
//            if (flag2 && flag1) {
//                return p;
//            }
//        }
//    }
//}
//
//static tuple<string, int, int> BuildingMiller(int bit, vector<int>& c, int t) {
//    // Инициализация переменных и кортежа
//    tuple<string, int> resultat = { "", 0 }; // Результат теста Миллера-Рабина
//    vector<int> geted; // Вектор для хранения значений
//    int z = 1; // Инициализация переменной z
//    bool f = true; // Флаг для цикла
//    int rnum; // Случайное число
//    int rpow; // Случайная степень
//    int max; // Максимальное значение
//    double counter = 0; // Счетчик
//    string znak; // Строка для хранения знака
//
//    while (true) { // Бесконечный цикл
//        z = 1; // Обнуление z
//        f = true; // Установка флага в true
//        geted = {}; // Очистка вектора geted
//
//        while (f && geted.size() < 1) { // Цикл до выполнения условия или заполнения вектора
//            z = 1; // Обнуление z
//            for (size_t i = 0; i < c.size(); i++) { // Цикл по элементам вектора c
//                if (c[i] > pow(2, bit - 1) - 1) { // Проверка условия
//                    break; // Выход из цикла
//                }
//                for (max = 1; pow(c[i], max) <= pow(2, bit - 1); max++) { // Цикл для вычисления максимальной степени
//                }
//                // Генерация случайной степени и числа
//                rpow = rn(1, max - 1);
//                rnum = rn(0, rpow);
//                // Вычисление значения z
//                z *= pow(c[i], rnum);
//                if (z > pow(2, bit - 1) - 1) { // Проверка условия
//                    z /= pow(c[i], rnum); // Возвращение значения z к предыдущему состоянию
//                    if (z >= pow(2, bit - 2)) { // Проверка условия
//                        if (find(geted.begin(), geted.end(), z) >= geted.end()) { // Проверка наличия значения z в векторе geted
//                            geted.push_back(z); // Добавление значения z в вектор
//                        }
//                        z = 1; // Обнуление z
//                        f = false; // Установка флага в false
//                    }
//                }
//            }
//        }
//        // Выбор случайного значения из вектора geted
//        rnum = rn(0, geted.size() - 1);
//        int m = geted[rnum];
//        int n = 2 * m - 1;
//        resultat = MillerTest(n, c, t); // Выполнение теста Миллера-Рабина
//        tuple<string, int> result_ver;
//        if (get<1>(resultat) == 0) { // Проверка результата теста
//            result_ver = MillerTest(n, c, 1); // Выполнение теста Миллера-Рабина с t = 1
//            if (get<1>(result_ver) == 1) { // Проверка результата теста
//                counter++; // Увеличение счетчика
//            }
//        }
//        else { // Если результат не нулевой
//            result_ver = MillerTest(n, c, 1); // Выполнение теста Миллера-Рабина с t = 1
//            if (get<1>(result_ver) == 1) { // Проверка результата теста
//                znak = '+'; // Установка значения строки
//            }
//            else {
//                znak = '-'; // Установка значения строки
//            }
//        }
//        if (get<1>(resultat) == 1) { // Проверка результата теста
//            return make_tuple(znak, n, counter); // Возвращение кортежа
//        }
//    }
//}
//
//static tuple<string, int, int> BuildingPoklington(int bit, vector<int>& c, int t) {
//    // Функция BuildingPoklington принимает на вход количество бит bit, вектор целых чисел c и число t.
//    // Ожидается, что вектор c содержит возможные делители числа n - 1.
//
//    tuple<string, int> resultat = { "", 0 }; // Инициализируем результат как пустой кортеж.
//
//    vector<int> geted; // Вектор для хранения полученных значений.
//    int z = 1; // Переменная для хранения промежуточных результатов.
//    bool f = true; // Флаг для управления циклом.
//    int rnum; // Случайное число.
//    int rpow; // Степень случайного числа.
//    int max; // Максимальная степень.
//    int n; // Переменная для хранения сгенерированного числа.
//    double counter = 0; // Счетчик простых чисел.
//    string znak; // Переменная для хранения знака.
//
//    // Бесконечный цикл для построения чисел.
//    while (true) {
//        z = 1; // Сбрасываем значение переменной z.
//        f = true; // Устанавливаем флаг f в true.
//        geted = {}; // Очищаем вектор geted.
//        vector<int> delit; // Вектор для хранения делителей.
//
//        // Цикл для генерации чисел с заданными условиями.
//        while (f && geted.size() < 1) {
//            z = 1; // Сбрасываем значение переменной z.
//            for (int i = 0; i < c.size(); i++) {
//                vector<int> delitt; // Вектор для временного хранения делителей.
//                if (c[i] > pow(2, bit / 2 + 1) - 1) { // Если текущий делитель больше максимального значения, выходим из цикла.
//                    break;
//                }
//                for (max = 1; pow(c[i], max) <= pow(2, bit / 2 + 1); max++) {
//                    // Вычисляем максимальную степень текущего делителя.
//                }
//                rpow = rn(1, max - 1); // Генерируем случайную степень.
//                rnum = rn(0, rpow); // Генерируем случайное число.
//                z *= pow(c[i], rnum); // Умножаем z на текущий делитель в случайной степени.
//                if (z > pow(2, bit / 2 + 1) - 1) {
//                    z /= pow(c[i], rnum); // Если z превышает пороговое значение, корректируем значение z.
//                    if (z >= pow(2, bit / 2)) {
//                        if (find(geted.begin(), geted.end(), z) >= geted.end()) {
//                            geted.push_back(z); // Добавляем z в вектор geted.
//                        }
//                        z = 1; // Сбрасываем значение переменной z.
//                        f = false; // Устанавливаем флаг f в false.
//                        delit = delitt; // Копируем временный вектор delitt в delit.
//                    }
//                }
//                else {
//                    if (rnum != 0) {
//                        delitt.push_back(c[i]); // Добавляем текущий делитель во временный вектор delitt.
//                    }
//                }
//            }
//        }
//        n = rn(pow(2, bit / 2 - 1), pow(2, bit / 2) - 1); // Генерируем случайное число в заданном диапазоне.
//        n = n * geted[0]; // Умножаем n на первое полученное значение из вектора geted.
//        n++; // Увеличиваем n на 1.
//        resultat = PoklingtonTest(n, delit, t); // Проверяем число на простоту.
//        tuple<string, int> result_ver; // Результат проверки числа на простоту.
//
//        // Если число составное, проверяем его еще раз с использованием всех делителей из вектора c.
//        if (get<1>(resultat) == 0) {
//            result_ver = PoklingtonTest(n, c, 1);
//            if (get<1>(result_ver) == 1) {
//                counter++; // Увеличиваем счетчик простых чисел.
//            }
//        }
//        else {
//            // Если число вероятно простое, проверяем его еще раз с использованием всех делителей из вектора c.
//            result_ver = PoklingtonTest(n, c, 1);
//            if (get<1>(result_ver) == 1) {
//                znak = '+'; // Запоминаем знак '+', если число простое.
//            }
//            else {
//                znak = '-'; // Запоминаем знак '-', если число составное.
//            }
//        }
//        // Если число вероятно простое, возвращаем кортеж с результатом и информацией о количестве простых чисел.
//        if (get<1>(resultat) == 1) {
//            return make_tuple(znak, n, counter);
//        }
//    }
//}
//
//
//
//int main() {
//    setlocale(LC_ALL, "russian");
//
//    // Создаем вектор c, содержащий простые числа до 500, используя решето Эратосфена.
//    vector <int> c = Eratosphene(500);
//
//    std::cout << "Простые числа до 500: \n";
//        for (int prime : c) {
//            std::cout << prime << " ";
//        }
//    std::cout << "\n\n" << std::endl;
//
//    // Переменная для хранения длины числа в битах, вводимая пользователем.
//    int bit;
//    cout << "Введите длину в битах: ";
//    cin >> bit;
//
//    // Переменная для хранения случайного числа.
//    int p;
//
//    // Вектор кортежей для хранения результатов теста Миллера-Рабина.
//    vector<tuple<string, int, int>> miller_res;
//
//    // Вектор для хранения сгенерированных простых чисел.
//    vector<int> miller_res_p;
//
//    // Кортеж для хранения результата проверки простоты числа методом Миллера-Рабина.
//    tuple<string, int, int> miller_result;
//
//    // Генерируем 10 случайных чисел и проверяем их на простоту методом Миллера-Рабина.
//    for (size_t i = 0; i < 10; i++) {
//        miller_result = BuildingMiller(bit, c, 100); // Генерируем случайное число и проверяем его на простоту.
//        p = get<1>(miller_result);// Получаем сгенерированное число.
//
//        // Если сгенерированное число еще не было добавлено в результаты, добавляем его.
//        if (find(miller_res_p.begin(), miller_res_p.end(), p) >= miller_res_p.end()) {
//            miller_res_p.push_back(p);
//            miller_res.push_back(miller_result);
//        }
//        else {
//            i--; // Если число уже было сгенерировано, повторяем генерацию.
//        }
//    }
//
//    cout << "MILLER\n";
//    cout << "+";
//    for (size_t i = 0; i < 10; i++) {
//        cout << "--------+";
//    }
//    cout << endl;
//
//    // Выводим номера столбцов в таблице.
//    cout << "|";
//    for (size_t i = 0; i < 10; i++) {
//        cout << setw(8) << i + 1 << "|";
//    }
//    cout << endl;
//
//    cout << "+";
//    for (size_t i = 0; i < 10; i++) {
//        cout << "--------+";
//    }
//    cout << endl;
//
//    // Выводим сгенерированные числа в таблицу.
//    cout << "|";
//    for (size_t i = 0; i < 10; i++) {
//        cout << setw(8) << get<1>(miller_res[i]) << "|";
//    }
//    cout << endl;
//
//    cout << "+";
//    for (size_t i = 0; i < 10; i++) {
//        cout << "--------+";
//    }
//    cout << endl;
//
//    // Выводим результаты теста (простое или составное) в таблицу.
//    cout << "|";
//    for (size_t i = 0; i < 10; i++) {
//        cout << setw(8) << get<0>(miller_res[i]) << "|";
//    }
//    cout << endl;
//
//    cout << "+";
//    for (size_t i = 0; i < 10; i++) {
//        cout << "--------+";
//    }
//    cout << endl;
//
//    // Выводим количество итераций для проверки числа.
//    cout << "|";
//    for (size_t i = 0; i < 10; i++) {
//        cout << setw(8) << get<2>(miller_res[i]) << "|";
//    }
//    cout << endl;
//
//    cout << "+";
//    for (size_t i = 0; i < 10; i++) {
//        cout << "--------+";
//    }
//    cout << endl;
//    //------------------------------------------------------
//
//    // Вектор для хранения результатов теста Поклингтона.
//    vector<tuple<string, int, int>> pokling_res;
//
//    // Вектор для хранения сгенерированных чисел в тесте Поклингтона.
//    vector<int> pokling_res_p;
//
//    // Кортеж для хранения результата проверки числа методом Поклингтона.
//    tuple<string, int, int> pokling_result;
//
//    // Генерируем 10 случайных чисел и проверяем их на простоту методом Поклингтона.
//    for (size_t i = 0; i < 10; i++) {
//        pokling_result = BuildingPoklington(bit, c, 100);// Генерируем случайное число и проверяем его на простоту.
//        p = get<1>(pokling_result);// Получаем сгенерированное число.
//
//        // Если сгенерированное число еще не было добавлено в результаты, добавляем его.
//        if (find(pokling_res_p.begin(), pokling_res_p.end(), p) >= pokling_res_p.end()) {
//            pokling_res_p.push_back(p);
//            pokling_res.push_back(pokling_result);
//        }
//        else {
//            i--;// Если число уже было сгенерировано, повторяем генерацию.
//        }
//    }
//
//    cout << "\nPOKLINGTON\n";
//    cout << "+";
//    for (size_t i = 0; i < 10; i++) {
//        cout << "--------+";
//    }
//    cout << endl;
//
//    // Выводим номера столбцов в таблице
//    cout << "|";
//    for (size_t i = 0; i < 10; i++) {
//        cout << setw(8) << i + 1 << "|";
//    }
//    cout << endl;
//
//    cout << "+";
//    for (size_t i = 0; i < 10; i++) {
//        cout << "--------+";
//    }
//    cout << endl;
//
//    // Выводим сгенерированные числа в таблицу.
//    cout << "|";
//    for (size_t i = 0; i < 10; i++) {
//        cout << setw(8) << get<1>(pokling_res[i]) << "|";
//    }
//    cout << endl;
//
//    cout << "+";
//    for (size_t i = 0; i < 10; i++) {
//        cout << "--------+";
//    }
//    cout << endl;
//
//    // Выводим результаты теста (простое или вероятно составное) в таблицу.
//    cout << "|";
//    for (size_t i = 0; i < 10; i++) {
//        cout << setw(8) << get<0>(pokling_res[i]) << "|";
//    }
//    cout << endl;
//
//    cout << "+";
//    for (size_t i = 0; i < 10; i++) {
//        cout << "--------+";
//    }
//    cout << endl;
//
//    // Выводим количество простых делителей для каждого числа в таблицу.
//    cout << "|";
//    for (size_t i = 0; i < 10; i++) {
//        cout << setw(8) << get<2>(pokling_res[i]) << "|";
//    }
//    cout << endl;
//
//    cout << "+";
//    for (size_t i = 0; i < 10; i++) {
//        cout << "--------+";
//    }
//    cout << endl;
//    //----------------------------------------------------------------------
//    cout << "\nGOSTR\n";
//    cout << "+";
//    for (size_t i = 0; i < 10; i++) {
//        cout << "--------+";
//    }
//    cout << endl;
//
//    // Выводим номера столбцов в таблице.
//    cout << "|";
//    for (size_t i = 0; i < 10; i++) {
//        cout << setw(8) << i + 1 << "|";
//    }
//    cout << endl;
//
//    cout << "+";
//    for (size_t i = 0; i < 10; i++) {
//        cout << "--------+";
//    }
//    cout << endl;
//
//    cout << "|";
//
//    // Генерируем случайное начальное значение индекса для вектора простых чисел.
//    int rand = rn(0, (c.size() - 10) / 10) * 10;
//
//    // Выводим сгенерированные числа в таблицу, преобразуя их с помощью функции GOSTP341004.
//    for (size_t i = 0; i < 10; i++) {
//        int znak = c[rand + i]; // Получаем число из вектора простых чисел.
//        cout << setw(8) << GOSTP341004(c[rand + i], bit) << "|"; // Преобразуем число и выводим его в таблицу.
//    }
//    cout << endl;
//
//    cout << "+";
//    for (size_t i = 0; i < 10; i++) {
//        cout << "--------+";
//    }
//    cout << endl;
//
//    return 0;
//}